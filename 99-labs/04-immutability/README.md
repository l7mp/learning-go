# Cloud-native patterns: Immutability and loose coupling

In the course of this lab and the following ones we will gradually improve our rudimentary SplitDim web app into a fully fledged cloud native app that is stateless, scalable and resilient. Recall, SplitDim helps groups of people keep track of money transfers between themselves and clear debts. 

![SplitDim logo, generated by logoai.com.](/99-labs/fig/splitdim-logo.png)

Currently the app uses a local database maintained in memory: we know that this is not safe under scaling and restarting pods. The below tasks guide you in making the web app stateless by state externalization. The tasks are followed by tests; pass each test to complete the lab.

## Table of Contents

1. [Preliminaries](#preliminaries)
2. [A key-value store client](#a-key-value-store-client)
3. [A persistent datalayer](#a-key-value-store-datalayer)
4. [Deploy to Kubernetes](#deploy-to-kubernetes)

## Preliminaries

Recall, SplitDim is a web app that lets groups of people keep track of who owns who. The web service implements the following API endpoints:
- `GET /`: serves a static HTML/JS artifact that you can use to interact with the app from a browser;
- `POST /api/transfer`: register a transfer between two users for a given amount;
- `GET /api/accounts`: return the balance for each registered user;
- `GET /api/clear`: return a minimal list of transfers that would allow users to clear their debts; and
- `GET /api/reset`: reset all balances to zero.

The data layer is currently rather primitive, maintaining the entire account database in memory:

``` go
type Account struct {
    // The name of the account holder.
    Holder string `json:"holder"`
    // Current balance.
    Balance int `json:"balance"`
}

type localDB struct {
    // accounts maintains the balance for each user name
    accounts map[string]int
    // The read-write mutex makes sure concurrent access is safe.
    mu sync.RWMutex
}

// NewDataLayer creates a new database of accounts.
func NewDataLayer() api.DataLayer {
    return &localDB{accounts: make(map[string]int)}
}
```

This is not ideal for a number of reasons:
- first, pods in Kubernetes are ephemeral: once the `splitdim` Deployment is restarted for some reason all internal state of all the pods, together with the account database, is lost (*persistence*);
- second, we cannot scale the web app, as the accounts database would then be split across the pods' in-memory databases, leading to inconsistent state (*scalability*).

Cloud native apps are, in contrast, stateless, storing all *resource state* in a safe persistent external database (*immutability*). We provide a barebones key-value store called `kvstore` (see `/99-labs/code/kvstore`) for this purpose. The key-value store exposes a simple API:
- the database stores a list of key-value pairs, where keys are represented as strings and values are represented as versioned strings; recall, versions are used to ensure eventual consistency:
  ```go
  type VersionedKeyValue struct {
      Key string `json:"key"`
      VersionedValue
  }

  type VersionedValue struct {
      Value   string `json:"value"`
      Version int    `json:"version"`
  }
  ```
- `GET /api/get?id=<id> `: get versioned value for the key given in the query parameter with the name id;
- `POST /api/put, body: {"key":<key>, "value":<value>, "version":<version>}`: insert the key-value pair into the database (only if the current version equals the specified version);
- `GET /api/reset`: remove all key-value pairs from the store; and
- `GET /api/list`: list the stored versioned key-value pairs.

The key-value store persists the store into a transaction log that is by default created at `/tmp/translog.log` and restores the store on startup from the persisted log.

Make sure to familiarize yourself with the workings of `kvstore`: 
- start the key-value store: the server will listen at `localhost:8081`:
  ```shell
  cd /99-labs/code/kvstore
  go run kvstore.go 
  ```
- insert the key-value pair `key1=1` at version 0 into the store:
  ```shell
  curl -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"1","version":0}' http://localhost:8081/api/put
  ```
- reinserting the same key with a different value `key1=2` at the same version 0 will fail, since the version in the store is now 1:
  ```shell
  curl -i -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"2","version":0}' http://localhost:8081/api/put
  HTTP/1.1 428 Precondition Required
  ```
- query the currently stored value and version in the database for `key1`:
  ```shell
  curl -X GET http://localhost:8081/api/get?id=key1
  {"value":"1","version":1}
  ```
- insert the new value with the new version and then list the entire content of the database:
  ``` shell
  curl -i -X POST -H "Content-Type: application/json" --data '{"key":"key1","value":"2","version":1}' http://localhost:8081/api/put
  curl --request GET http://localhost:8081/api/list
  [{"key":"key1","value":"2","version":2}]
  ```
- restarting the key-value store will restore the database from the transaction log:
  ```shell
  ^-C
  go run kvstore.go 
  kvstore.go:120: Using transaction log in "/tmp/translog.log"
  filelog.go:26: Opening/creating transaction log in file /tmp/translog.log
  Read-events: New event transactionlog.Event{Sequence:0x1, Type:"put", Value:"{\"key\":\"key1\",\"value\":\"1\",\"version\":0}"}
  Read-events: New event transactionlog.Event{Sequence:0x2, Type:"put", Value:"{\"key\":\"key1\",\"value\":\"2\",\"version\":1}"}
  kvstore.go:183: Starting HTTP server at :8081
  ```
- clear the database:
  ```shell
  curl --request GET http://localhost:8081/api/reset
  ```

# A key-value store client

Currently, querying the key-value store from a Go program is somewhat cumbersome: we have to marshal Go types to JSON before making each call, then make the actual HTTP call to the key-value store server, remembering that `get` is implemented as a HTTP POST request while `list` and `reset` use HTTP GET, and then unmarshaling the result into an appropriate Go struct, checking errors, etc. This gets boring (and error-prone) very soon.

Wouldn't it be nice to just call the key-value store through a client library that would expose the entire key-value store API as simple-to-use Go functions, and then do the heavy lifting in the background? Wouldn't it be even nicer, if the `kvstore` package would provide that client library?

This is what we are going to implement next. Enter the directory of the key-value store (`99-labs/code/kvstore`), and in particular the `client` package in `/pkg/client/`. This directory already contains some code for the API (see `api.go`), plus a set of tests (see `client_test.go`) that we will want eventually to pass.

``` go
package client

import "kvstore/pkg/api"

// Client is a generic client interface to the key-value store.
type Client interface {
    // Get returns the value and version stored for the given key, or an error if something goes wrong.
    Get(key string) (api.VersionedValue, error)
    // Put tries to insert the given key-value pair with the specified version into the store.
    Put(vkv api.VersionedKeyValue) error
    // List returns all values stored in the database.
    List() ([]api.VersionedKeyValue, error)
    // Reset removes all key-value pairs.
    Reset() error
}
```

Your task is to implement this interface. Some help:
1. Open a new file, say, `client.go`, declare that the file belongs to the `client` package, and add some necessary package imports:
   ``` go
   package client
   
   import (
       "bytes"
       "encoding/json"
       "fmt"
       "log"
       "net/http"
   
       "kvstore/pkg/api"  // This is needed to use our own key-value store API.
   )
   ```

2. Create a struct, this will become our implementation of the `Client` interface once we add the missing functions. The single field called `url` in the `client` struct will store the URL where the key-value store server is available at:
   ``` go
   type client struct {
       url string
   }
   ```

> [!NOTE]
> 
> The `client` struct will *not* be exported from the package (letter case matters!).

3. Create a constructor. Recall, this entails writing a `NewClient` function that takes the arguments necessary to instantiate the `client` struct (currently, this will be the `address:port` for the key-value store server), constructs the struct, and then *returns a pointer to the struct as an interface*. This makes sure that the caller of our `NewClient` function can access only the methods exposed by the `Client` interface on the returned pointer, but nothing else:
   ``` go
   func NewClient(addr string) Client {
       return &client{url: "http://" + addr}
   }
   ```

> [!NOTE]
> 
> Make sure you understand this constructor pattern, you will find it everywhere in Go code.

4. At this point, we are ready to actually implement the `Client` interface. Let us add the implementation for the `get` method first; recall, this receives a string key as an argument and returns the corresponding key and version as an `api.VersionedValue`:
   ``` go
   // Get returns the value and version stored for the given key, or an error if something goes wrong.
   func (c *client) Get(key string) (api.VersionedValue, error) {
      //this will append the query parameter formatted to the url
      uri, _ := url.Parse(c.url + "/api/get")
	  q := uri.Query()
	  q.Set("id", key)
	  uri.RawQuery = q.Encode()
       ...
   }
   ```

   The function itself will have to perform the following steps:
   - make a HTTP GET call to the HTTP server at the URL `c.url` (`c` is the receiver of the `Get` function of our implementation type `client`) at the API endpoint `/api/get` using the `key` argument as the query id parameter value:
     ```go
     r, err := http.Get(uri.String())
     ```
   - return an empty `api.VersionedValue{}` and an error if something goes wrong,
   - check if the return status is 200 (`http.StatusOK`) and return an empty `api.VersionedValue{}` and an error if not,
   - unmarshal the HTTP response body into a value of type `api.VersionedValue` or an error if this fails, and
   - return the unpacked value and a `nil` error.

4. Implement the `put` method next; recall, this function receives a key-value-version tuple of type `api.VersionedKeyValue` and tries to insert it into the key-value store:
   ``` go
   // Put tries to insert the given key-value pair with the specified version into the store.
   func (c *client) Put(vkv api.VersionedKeyValue) error {
   
       ...
   }
   ```

   The function itself will have to perform the following steps:
   - marshal argument `vkv` into JSON and return the error if something goes wrong,
   - make a HTTP POST call to the API endpoint `/api/put` (don't forget to prefix the URL with the server address, `c.url`), encoding the JSON-encoded key-value pair as the request body,
   - return an error if something went wrong or the response status is not HTTP 200, and
   - return a `nil` error.

4. Implement the `list` method; recall, this function returns the list of all key-value-version tuples as a slice of type `[]api.VersionedKeyValue`
   ``` go
   // List returns all values stored in the database.
   func (c *client) List() ([]api.VersionedKeyValue, error) {
       ...
   }
   ```

   The function will have to perform the following steps:
   - make a HTTP GET call to the API endpoint `/api/list`,
   - return an empty slice and an error if something went wrong or the response status is not HTTP 200,
   - unmarshal the response body (a JSON byte slice) into a value of type `[]api.VersionedKeyValue` or return an error if this fails, and
   - return the unmarshaled value and a `nil` error.

5. Finally, implement the `reset` method, which, recall, will remove all key-value pairs from the store:
   ``` go
   // Reset removes all key-value pairs.
   func (c *client) Reset() error {
       ...
   }
   ```

   The function is very simple: make a HTTP GET call to the API endpoint `/api/reset` and return an error if the status is not HTTP 200.
   
And that is all. We have implemented a `kvstore/pkg/client` library of functions that any code that wants to talk to the key-value store can import and use without having to worry about marshaling/unmarshaling parameters in/out to/from HTTP requests/responses, etc.

> ✅ **Check**
>
> Run the below test in `99-labs/code/kvstore` to check whether you have successfully completed the task. If all goes well, you should see the output `PASS`.
> ``` sh
> go test ./pkg/client/... -v -count 1
> PASS
> ```
> You don't have to start the key-value store server for the test to run: the test will conveniently fire up a server in the background and deletes it once ready.

# A key-value store datalayer

So let us write a key-value store datalayer for our SplitDim web app. Recall, the current version keeps the accounts in memory; now we want to move this *resource state* into the key-value store. The app will have to talk a lot to the key-value store; luckily, this will be significantly simpler thanks to the client library we have just written.

1. Enter the directory under `99-labs/code/splitdim`. Make sure all tests from the previous lab pass at this point.

2. As usual, first we have to get our package imports right.

   As we are going to use the key-value store client library we will have to add that to the package dependencies of `splitdim`, and since the key-value store uses the `transactionlog` package we have an implicit dependency to that too, and we also need to add the necessary "replace" rules to make sure Go finds our modules in the local file system:
   ``` shell
   go get kvstore
   go mod edit -replace kvstore=../kvstore
   go get transactionlog
   go mod edit -replace transactionlog=../transactionlog
   go mod tidy
   go mod vendor
   ```
   
> [!NOTE]
> 
> Transitive dependencies are usually handled by Go automatically, but this time we need to do this manually due to the "replace" rules.

> [!NOTE]
> 
> This will throw some errors along the way, but the eventual `go mod tidy` will get everything right. The final `go mod vendor` makes sure that all dependencies get copied into the local `vendor/` directory, which will simplify building the container image later.

3. Since we are going to implement multiple data layers side by side, we need a way to select among them (*manageability*, see later) when starting the app. We will use two environment variables, `KVSTORE_MODE` and `KVSTORE_ADDR`, for that purpose.

   First, we define two globals that will hold the actual parameters.

   ``` go
   // KVStoreMode defines the data layer mode (local/redis/kvstore).
   var KVStoreMode = "local"
   
   // KVStoreAddr stores the key-value store address as a DNS domain name or IP address.
   var KVStoreAddr = "localhost:8001"
   ```

   Then, as the `main` function starts we read the environment variables and initialize the datalayer based on the current setting. 
   
   ``` go
   var db api.DataLayer

   func main() {
       
       if os.Getenv("KVSTORE_MODE") != "" {
           KVStoreMode = os.Getenv("KVSTORE_MODE")
       }
       if os.Getenv("KVSTORE_ADDR") != "" {
           KVStoreAddr = os.Getenv("KVSTORE_ADDR")
       }
       
       switch KVStoreMode {
       case "kvstore":
           log.Printf("Using the kvstore datalayer using at %q", KVStoreAddr)
           db = kvstore.NewDataLayer(KVStoreAddr)
       case "local":
           fallthrough
       default:
           log.Println("Using the local datalayer")
           db = local.NewDataLayer()
       }
       ...
   }
   ```
   
   The `local` datalayer will start as the default, but starting the app with `KVSTORE_MODE=kvstore go run main.go` will start the key-value store datalyer instead (once we get to write it).

4. Create a new (sub)package under `pkg/db/kvstore`; this will implement the data layer of the web app with the account database moved to the key-value store.

   ``` go
   package kvstore
   
   import (
       "fmt"
       "log"
       "strconv"
   
       clientapi "kvstore/pkg/api"
       "kvstore/pkg/client"
   
       "splitdim/pkg/api"
   )
   ```
   
   Some explanation: first we import some standard Go libs, that's completely normal. Then we import the key-value store API and client packages; recall, we will use these to actually talk to the key-value store. Then we import our own API. A small caveat: in order to avoid having two packages in the local namespace called `api` (one for the key-value store client library and another one for our own API), we alias the package import from `kvstore/pkg/api` using the shorthand name `clientapi`. This will nicely distinguish the two API packages.

5. Create a struct that will hold the new data layer.

   ``` go
   type kvstore struct {
       client.Client
   }
   
   // NewDataLayer creates a new database of scores.
   func NewDataLayer(kvStoreAddr string) api.DataLayer {
       return &kvstore{Client: client.NewClient(kvStoreAddr)}
   }
   ```

   A small trick: the `kvstore` struct embeds the key-value store client. Recall, composition in Go is extremely powerful, since from this point all the methods defined on the embedded client are also callable on the `kvstore` that embeds it, that is, we can shortcut `kvstore.client.Get(...)` to `kvstore.Get(...)` and things will just magically work (except when not, see later).

6. Next we write a simple helper called `setBalance`, which will simplify the process of writing a new balance into the key-value store. 

   ``` go
   func (db *kvstore) setBalance(user string, amount int) error { ... }
   ```

   When using our key-value store, increasing the  balance of a user by `amount` is a sequence of a consecutive `get` to obtain the current `balance` plus the current version stored in the key-value store, followed by a `put(balance+amount)` to set the new balance. Decrease would be similar, but we use `put(balance-amount)`. It is completely normal for the `put` to fail: this happens when another `splitdim` instance (when we scale the app out to several pods) has made a concurrent transaction between our `get` and `put` calls.

   The `setBalance` function performs the following steps:
   - obtain the current balance for the user (and handle errors!): `vv, err := db.Get(user)`,
   - increase/decrease (based on whether the argument `amount` is positive or negative) the balance of the user:
     ```go
     balance, _ := strconv.Atoi(vv.Value)            // Convert to integer: should be safe
     vv.Value = fmt.Sprintf("%d", balance+amount)    // Set the new balance in the value
     vkv := clientapi.VersionedKeyValue{user, vv}    // Create a VersionedKeyValue
     ```
   - call `db.Put(vkv)` to upload the new balance to the key-value store and return an error if this fails,
   - return a `nil` error to indicate that the balance has been set.

7. Write the `Transfer` function: recall, this function moves `t.Amount` from `t.Sender` to `t.Receiver`:
   ```go
   func (db *kvstore) Transfer(t api.Transfer) error { ... }
   ```

   The function performs the following steps:
   - make a quick sanity check: return an "invalid transfer" error if the `Sender` or the `Receiver` field of the transfer argument `t` is empty or the sender and the receiver is the same person,
   - call the `db.setBalance(t.Sender, t.Amount)` *in an infinite loop until it succeeds without an error* to remove `t.Amount` from the balance of `t.Sender`,
   - call the `db.setBalance(t.Receiver, -t.Amount)` *in an infinite loop until it succeeds without an error* to add `t.Amount` to the balance of `t.Receiver`.

   Calling the `setBalance` function in an infinite loop is necessary at this point, since it is completely normal for the `put` call after the `get` to fail due to a version mismatch (this is the price we pay for using a *loosely coupled* API). Later, we will implement some simple *resilience* patterns to make this more robust. 

> [!WARNING]
> 
> Don't do the above in real-life: if the first `setBalance` call succeeds but the second fails for some reason then we get a halfway applied transaction: we have already removed the amount from the balance of the sender but failed to add it to the balance of the receiver. This will then make it impossible to clear the debts and leaves the database in an inconsistent state. 
>
> In a real-life application these two steps should be performed as a single *transaction*; since our key-value store does not implement transactions we spare this step for now (but see the next lab). 

8. Write the `AccountList` function: recall, this function will return the list of all accounts as pairs of a holder and a balance:
   ```go
   func (db *kvstore) AccountList() ([]api.Account, error) { ... }
   ```

   The function performs the following steps:
   - list the key-value store to get all the accounts: `accounts, err := db.List()` (and handle errors!),
   - create an slice that we will return: `ret := []api.Account{}`
   - iterate through `accounts` and for each item first convert the value (the balance) to an int using `strconv.Atoi` and then add a new account to the returned list, and
   - return the resultant slice `ret` and a `nil` error.

8. Our most problematic call has always been `Clear`, due to the relatively complex algorithm to be implemented. Recall, this function returns the minimal list of transfers that allow our users to clear all debts. 
   ```go
   func (db *kvstore) Clear() ([]api.Transfer, error) { ... }
   ```

   Luckily, we have already written the difficult part (the algorithm) during the previous lab. Here, we will need to list the account database again from the key-value store, convert it into a `make(map[string]int)`, and then reuse the same algorithm as in the previous lab to obtain the list of transfers that clears the debts. 

> [!TIP]
> 
> Since we seem to be reusing the same algorithm from the previous lab to calculate the "clearing" solution, we can even refactor that functionality out into a separate package (say, `splitdim/pkg/clear`) and call that lib every time we want to obtain the transfer list. The signature of the function could be, say:
> ```go
> // Clear clears the debts for the accounts given as argument. Meanwhile, it updates "accounts", so always pass a copy to this function.
> func Clear(accounts map[string]int) ([]api.Transfer, error) { ... }
> ```
> 
> Feel free to experiment with writing this package.

9. Finally, the `Reset` function of the data layer is so simple that we reproduce it below verbatim:
   ```go
   // Reset sets all balances to zero.
   func (db *kvstore) Reset() error {
       	return db.Client.Reset()
   }
   ```

   Calling simply `db.Reset()` in the above would not work. Remember, `kvstore` embeds the key-value store client and, curiously, in this case both the embedding struct `kvstore` (of the `Datalayer` interface) and the embedded `Client` interface implements a `Reset` function. If we called `db.Reset()` directly on the outer object then we would recursively call ourselves in an infinite loop. Calling `db.Client.Reset()` makes sure that we call the `Reset` function of the embedded object.

If all goes well (and all compile errors are taken care of), then we can make a local test:
- start the key-value store in a new terminal:
  ```shell
  cd 99-labs/code/kvstore
  go run kvstore.go 
  server.go:184: Starting HTTP server at :8081
  ```
- start the `splitdim` app: note the environment variables passed in to the app so that it actually starts with our shiny new key-value store data layer that will talk to the key-value store:
  ```shell
  KVSTORE_MODE=kvstore KVSTORE_ADDR=localhost:8081 go run main.go
  ```
- perform some transactions and check the results:
  ```shell
  export EXTERNAL_IP=localhost
  export EXTERNAL_PORT=8080
  curl -H "Content-Type: application/json" --request POST --data '{"sender":"a","receiver":"b","amount":1}' http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/transfer
  curl -H "Content-Type: application/json" --request POST --data '{"sender":"b","receiver":"c","amount":1}' http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/transfer
  curl http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/clear
  [{"sender":"c","receiver":"a","amount":1}]
  ```

> ✅ **Check**
>
> Run the below test in `99-labs/code/splitdim` to check whether you have successfully completed the task. If all goes well, you should see the output `PASS`.
> ``` sh
> go test ./... --tags=httphandler,api,localconstructor,reset,transfer,accounts,clear -v -count 1
> PASS
> ```
> Note that the splitdim app and the key-value must both run for the tests to pass

## Deploy to Kubernetes

Once the local tests run, we can actually deploy the application to Kubernetes. To simplify this, we packaged the manifests necessary to build the container image for the key-value store and deploy it to Kubernetes; your job will be to build, deploy and expose the `splitdim` web app component. 

1. Make sure that Kubernetes is running (`minikube start`) and the Minikube load-balancer is functional (`minikube tunnel` is running in a terminal).

2. Build the `kvstore` image. This will make the container image available in the container registry of Minikube with the name `localhost/kvstore`:
   ```shell
   cd 99-labs/code/kvstore
   go mod vendor
   minikube image build -t localhost/kvstore -f deploy/Dockerfile .
   ```

3. Deploy the key-value store to Kubernetes using the pre-packaged manifest `deploy/kubernetes-statefulset.yaml` in `99-labs/code/kvstore`. This will run `kvstore` in a StatefulSet with one replica and expose it on a Service *internally* (external access to the key-value store would be a security hole) at the DNS name `kvstore.default`.
   ```shell
   kubectl apply -f deploy/kubernetes-statefulset.yaml
   ```

> [!NOTE]
>
> The full DNS name would be `kvstore.default.svc.cluster.local`, but usually only `kvstore` or `kvstore.default` is enough.

4. Re-build the `splitdim` image; the `Dockerfile` created during the previous lab should be reusable for this:
   ```shell
   cd 99-labs/code/splitdim
   go mod vendor
   minikube image build -t localhost/splitdim -f deploy/Dockerfile .
   ```

5. Copy the Kubernetes manifests we created during the previous lab (this is supposed to be called `deploy/kubernetes-local-db.yaml`) into a new file, say, `deploy/kubernetes-kvstore.yaml`, and modify it to make sure `splitdim` starts with the key-value store backend. This is achieved by passing in two environment variables to the Go program: `KVSTORE_MODE=kvstore` makes sure we select the key-value store backend and `KVSTORE_ADDR="kvstore.default:8081"` will contain the address of the key-value store. The only modification is, correspondingly, in the pod template of the `splitdim` Deployment:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: splitdim
     labels:
       app: splitdim
   spec:
     selector:
       matchLabels:
         app: splitdim
     template:
       metadata:
         labels:
           app: splitdim
       spec:
         containers:
         - name: splitdim
           image: localhost/splitdim:latest
           ports:
             - containerPort: 8080
           env:
           - name: KVSTORE_MODE
             value: kvstore
           - name: KVSTORE_ADDR
             value: "kvstore.default:8081"
   ```

6. Apply the manifests: `kubectl apply -f deploy/kubernetes-kvstore.yaml`. Listing the pods and services should result something like the below:
   ```shell
   kubectl get pod,service -o wide
   NAME                            READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
   pod/kvstore-0                   1/1     Running   0          23m   10.244.0.4   minikube   <none>           <none>
   pod/splitdim-6dd5565899-krldz   1/1     Running   0          11m   10.244.0.5   minikube   <none>           <none>
   
   NAME                 TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)        AGE    SELECTOR
   service/kubernetes   ClusterIP      10.96.0.1      <none>         443/TCP        7d5h   <none>
   service/kvstore      ClusterIP      None           <none>         8081/TCP       23m    app=kvstore
   service/splitdim     LoadBalancer   10.100.109.0   10.100.109.0   80:30033/TCP   13h    app=splitdim
   ```

### Tests

Store the external IP and port and do some quick tests with `curl`:

```shell
export EXTERNAL_IP=$(kubectl get service splitdim -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
export EXTERNAL_PORT=80
curl -H "Content-Type: application/json" --request POST --data '{"sender":"a","receiver":"b","amount":1}' http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/transfer
curl -H "Content-Type: application/json" --request POST --data '{"sender":"b","receiver":"c","amount":1}' http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/transfer
curl http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/clear
[{"sender":"c","receiver":"a","amount":1}]
```

> ✅ **Check**
> 
> Test your Kubernetes deployment. If all goes well, you should see the output `PASS`.
>   ``` sh
>   export EXTERNAL_IP=$(kubectl get service splitdim -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
>   export EXTERNAL_PORT=80
>   go test ./... --tags=httphandler,api,localconstructor,reset,transfer,accounts,clear -v -count 1
>   PASS
>   ```

### Scaling the web app

We have worked a lot, added a lot of functionality, even implemented a key-value store client, but it seems that we are back at where we left at the end of the previous lab: the same tests pass as before. It is worth stopping at this point for a moment to reminisce why we did the whole thing in the first place: to be able to scale the web app (this is impossible with a stateful `splitdim`) and to let our data survive a pod restart. Let's do some quick tests to check whether we have reached our goal!

Scale the `splitdim` Deployment to 3 pods:

``` shell
kubectl scale deployment splitdim --replicas=3
```

Try the same `curl` tests as above: if all goes well, you should see the same results.

> ✅ **Check**
> 
> Test your Kubernetes deployment with 3 `splitdim` pods. If all goes well, you should see the output `PASS`.
>   ``` sh
>   export EXTERNAL_IP=$(kubectl get service splitdim -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
>   export EXTERNAL_PORT=80
>   go test ./... --tags=httphandler,api,localconstructor,reset,transfer,accounts,clear -v -count 1
>   PASS
>   ```

### Persistence

Our little web app should at this point survive a full system restart. You can even stop Minikube and restart it, and the account database should still be there.

Fill the database with test data:

```shell
export EXTERNAL_IP=$(kubectl get service splitdim -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
export EXTERNAL_PORT=80
curl http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/reset
curl -H "Content-Type: application/json" --request POST --data '{"sender":"a","receiver":"b","amount":1}' http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/transfer
curl -H "Content-Type: application/json" --request POST --data '{"sender":"b","receiver":"c","amount":1}' http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/transfer
curl http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/clear
[{"sender":"c","receiver":"a","amount":1}]
```

Restart the web app and the key-value store:
```shell
kubectl rollout restart deployment splitdim
kubectl rollout restart statefulset kvstore
```

Wait a couple of seconds until all components restart and clear the balances again: you should see the same result.

```shell
curl http://${EXTERNAL_IP}:${EXTERNAL_PORT}/api/clear
[{"sender":"c","receiver":"a","amount":1}]
```

This concludes this lab: we have implemented a persistent data layer and deployed it to Kubernetes, and may even have had some (little) fun along the way!

<!-- Local Variables: -->
<!-- mode: markdown; coding: utf-8 -->
<!-- eval: (auto-fill-mode -1) -->
<!-- visual-line-mode: 1 -->
<!-- markdown-enable-math: t -->
<!-- End: -->
